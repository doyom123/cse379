


ARM Macro Assembler    Page 1 


    1 00000000                 AREA             lib, CODE, READWRITE
    2 00000000                 EXPORT           lab3
    3 00000000                 EXPORT           pin_connect_block_setup_for_uar
t0
    4 00000000                 EXPORT           uart_init
    5 00000000         
    6 00000000         
    7 00000000 00000014 
                       U0LSR   EQU              0x14        ; UART0 Line Status
                                                             Register
    8 00000000 0000000C 
                       U0LCR   EQU              0x0C        ; UART0 Line Contro
                                                            l Register
    9 00000000 E000C000 
                       U0BA    EQU              0xE000C000  ; UART0 Base Addres
                                                            s
   10 00000000         ; You'll want to define more constants to make your code
                        easier 
   11 00000000         ; to read and debug
   12 00000000         
   13 00000000         ; Memory allocated for user-entered strings
   14 00000000 45 6E 74 
              65 72 20 
              61 20 6E 
              75 6D 62 
              65 72 3A 
              20 20 00 prompt  =                "Enter a number:  ",0
   15 00000012         ; Additional strings may be defined here
   16 00000012 45 6E 74 
              65 72 20 
              61 20 64 
              69 76 69 
              73 6F 72 
              3A 20 00 prompt_divisor
                               =                "Enter a divisor: ", 0
   17 00000024 45 6E 74 
              65 72 20 
              61 20 64 
              69 76 69 
              64 65 6E 
              64 3A 20 
              00       prompt_dividend
                               =                "Enter a dividend: ", 0
   18 00000037 51 75 6F 
              74 69 65 
              6E 74 20 
              3D 20 00 response_quotient
                               =                "Quotient = ", 0
   19 00000043 52 65 6D 
              61 69 6E 
              64 65 72 
              20 3D 20 
              00       response_remainder
                               =                "Remainder = ", 0
   20 00000050                 ALIGN
   21 00000050         
   22 00000050         uart_init
   23 00000050 E92D4000        STMFD            SP!, {lr}
   24 00000054         



ARM Macro Assembler    Page 2 


   25 00000054 E3A01083        MOV              r1, #131
   26 00000058 E59F42C0        LDR              r4, =0xE000C00C
   27 0000005C E5841000        STR              r1, [r4]
   28 00000060         
   29 00000060 E3A01078        MOV              r1, #120
   30 00000064 E59F42B8        LDR              r4, =0xE000C000
   31 00000068 E5841000        STR              r1, [r4]
   32 0000006C         
   33 0000006C E3A01000        MOV              r1, #0
   34 00000070 E59F42B0        LDR              r4, =0xE000C004
   35 00000074 E5841000        STR              r1, [r4]
   36 00000078         
   37 00000078 E3A01003        MOV              r1, #3
   38 0000007C E59F429C        LDR              r4, =0xE000C00C
   39 00000080 E5841000        STR              r1, [r4]
   40 00000084         
   41 00000084 E8BD4000        LDMFD            SP!, {lr}
   42 00000088 E12FFF1E        BX               lr
   43 0000008C         
   44 0000008C         
   45 0000008C         lab3
   46 0000008C E92D4000        STMFD            SP!,{lr}    ; Store register lr
                                                             on stack
   47 00000090         
   48 00000090         ; Enter Dividend
   49 00000090 E59F4294        LDR              r4, =prompt_dividend
   50 00000094 EB00002E        BL               output_string ; print dividend 
                                                            prompt
   51 00000098 E59F428C        LDR              r4, =prompt_dividend
   52 0000009C EB000020        BL               read_string ; read user input
   53 000000A0 EB00002B        BL               output_string 
                                                            ; print user input
   54 000000A4         
   55 000000A4 E3A0000A        MOV              r0, #0x0A   ; print LF
   56 000000A8 EB00003A        BL               output_character
   57 000000AC         
   58 000000AC         ; Enter Divisor
   59 000000AC E59F427C        LDR              r4, =prompt_divisor
   60 000000B0 EB000027        BL               output_string ; print divisor p
                                                            rompt
   61 000000B4 E59F4274        LDR              r4, =prompt_divisor
   62 000000B8 EB000019        BL               read_string ; read user input 
   63 000000BC EB000024        BL               output_string 
                                                            ; print user input
   64 000000C0         
   65 000000C0 E3A0000A        MOV              r0, #0x0A   ; print LF
   66 000000C4 EB000033        BL               output_character
   67 000000C8         
   68 000000C8         ; Convert ASCII to int
   69 000000C8 E59F425C        LDR              r4, =prompt_dividend
   70 000000CC EB00003B        BL               atoi
   71 000000D0 E1A02000        MOV              r2, r0      ; save dividend_int
                                                             in r2
   72 000000D4 E59F4254        LDR              r4, =prompt_divisor
   73 000000D8 EB000038        BL               atoi
   74 000000DC E1A01000        MOV              r1, r0      ; move divisor_int 
                                                            in r1
   75 000000E0 E1A00002        MOV              r0, r2      ; move dividend_int
                                                             in r0



ARM Macro Assembler    Page 3 


   76 000000E4         
   77 000000E4         ; Perform calculation
   78 000000E4 EB000066        BL               div_and_mod ; Return: r0 = quot
                                                            ient, r1 = remainde
                                                            r
   79 000000E8         
   80 000000E8         ; Print Quotient
   81 000000E8 E59F4244        LDR              r4, =response_quotient
   82 000000EC EB000018        BL               output_string
   83 000000F0 E59F4240        LDR              r4, =prompt ; convert quotient 
                                                            int to ASCII
   84 000000F4 EB000044        BL               itoa
   85 000000F8 EB000015        BL               output_string
   86 000000FC         
   87 000000FC E3A0000A        MOV              r0, #0x0A   ; print LF
   88 00000100 EB000024        BL               output_character
   89 00000104         
   90 00000104         ; Print Remainder
   91 00000104 E59F4230        LDR              r4, =response_remainder
   92 00000108 EB000011        BL               output_string
   93 0000010C E59F4224        LDR              r4, =prompt
   94 00000110 E1A00001        MOV              r0, r1
   95 00000114 EB00003C        BL               itoa
   96 00000118 EB00000D        BL               output_string
   97 0000011C         
   98 0000011C E8BD4000        LDMFD            sp!, {lr}
   99 00000120 E12FFF1E        BX               lr
  100 00000124         
  101 00000124         read_string                          ; base address of s
                                                            tring passed into r
                                                            4
  102 00000124 E92D4010        STMFD            SP!, {lr, r4} ; Store register 
                                                            lr on stack
  103 00000128         rs_loop
  104 00000128 EB000011        BL               read_character
  105 0000012C E4C40001        STRB             r0, [r4], #1 ; store char into 
                                                            [r4], increment ind
                                                            ex
  106 00000130 EB000018        BL               output_character
  107 00000134 E350000D        CMP              r0, #0x0D   ; check if char CR
  108 00000138 1AFFFFFA        BNE              rs_loop     ; loop if char != C
                                                            R
  109 0000013C E3A05000        MOV              r5, #0
  110 00000140 E5645001        STRB             r5, [r4, #-1]! ; decrement buff
                                                             index, then append
                                                             NULL char
  111 00000144         
  112 00000144 E3A0000A        MOV              r0, #0x0A   ; print new line
  113 00000148 EB000012        BL               output_character ; 
  114 0000014C         
  115 0000014C E8BD4010        LDMFD            sp!, {lr, r4}
  116 00000150 E12FFF1E        BX               lr
  117 00000154         
  118 00000154         output_string                        ; base address of s
                                                            tring passed into r
                                                            4
  119 00000154 E92D401F        STMFD            SP!, {lr, r0-r4}
  120 00000158         os_loop
  121 00000158 E4D40001        LDRB             r0, [r4], #1 ; char loaded into



ARM Macro Assembler    Page 4 


                                                             r0, r4 post-indexe
                                                            d base updated 
  122 0000015C E59F11C0        LDR              r1, =U0BA   ; set r1 to UART0 B
                                                            ase Address
  123 00000160 EB00000C        BL               output_character ; output char 
                                                            in r0 
  124 00000164 E3500000        CMP              r0, #0      ; check if char is 
                                                            0
  125 00000168 1AFFFFFA        BNE              os_loop     ; loop if char != 0
                                                            
  126 0000016C         
  127 0000016C E8BD401F        LDMFD            sp!, {lr, r0-r4}
  128 00000170 E12FFF1E        BX               lr
  129 00000174         
  130 00000174         
  131 00000174         read_character                       ; Read Data
  132 00000174 E92D4000        STMFD            SP!,{lr}    ; Store register lr
                                                             on stack
  133 00000178 E59F01A4        LDR              r0, =0xE000C000 ; Load UART0 Ba
                                                            se Address
  134 0000017C         rstart
  135 0000017C E5D01014        LDRB             r1, [r0, #U0LSR] ; Load Status 
                                                            Register Addresss
  136 00000180 E2112001        ANDS             r2, r1, #1  ; Test RDR in Statu
                                                            s Register
  137 00000184 0AFFFFFC        BEQ              rstart      ; if RDR == 0 -> rs
                                                            tart
  138 00000188 E5D03000        LDRB             r3, [r0]    ; else Read byte fr
                                                            om receive register
                                                            
  139 0000018C E1A00003        MOV              r0, r3      ; Return char in r0
                                                            
  140 00000190 E8BD4000        LDMFD            sp!, {lr}
  141 00000194 E12FFF1E        BX               lr
  142 00000198         
  143 00000198         output_character                     ; char passed in th
                                                            rough r0
  144 00000198 E92D400E        STMFD            SP!,{lr, r1-r3} ; Store registe
                                                            r lr on stack
  145 0000019C         
  146 0000019C E1A03000        MOV              r3, r0      ; Store char argume
                                                            nt into r3
  147 000001A0 E59F017C        LDR              r0, =0xE000C000 ; Load UART0 Ba
                                                            se Address
  148 000001A4         tstart
  149 000001A4 E5D01014        LDRB             r1, [r0, #U0LSR] ; Load Status 
                                                            Register Addresss
  150 000001A8 E2112020        ANDS             r2, r1, #32 ; test THRE in Stat
                                                            us Register
  151 000001AC 0AFFFFFC        BEQ              tstart      ; if THRE == 0 -> t
                                                            start
  152 000001B0 E5C03000        STRB             r3, [r0]    ; else Store byte i
                                                            n transmit register
                                                            
  153 000001B4 E1A00003        MOV              r0, r3
  154 000001B8 E8BD400E        LDMFD            sp!, {lr, r1-r3}
  155 000001BC E12FFF1E        BX               lr
  156 000001C0         
  157 000001C0         atoi



ARM Macro Assembler    Page 5 


  158 000001C0         ; Args r4 = base address of char
  159 000001C0         ; r5 = sign bit, 1 if neg, 0 if pos
  160 000001C0         ; r2 = total
  161 000001C0         ; r3 = 10
  162 000001C0         
  163 000001C0         ; Return r0
  164 000001C0 E92D401C        STMFD            SP!, {lr, r2-r4}
  165 000001C4 E3A02000        MOV              r2, #0
  166 000001C8 E3A0300A        MOV              r3, #10
  167 000001CC         ; Check sign
  168 000001CC E3A05000        MOV              r5, #0
  169 000001D0 E4D40001        LDRB             r0, [r4], #1 ; Load sign bit
  170 000001D4 E350002D        CMP              r0, #0x2D
  171 000001D8 03A05001        MOVEQ            r5, #1      ; Set r5 = 0 if neg
                                                            ative
  172 000001DC         atoi_loop
  173 000001DC E4D40001        LDRB             r0, [r4], #1 ; Load char
  174 000001E0 E3500000        CMP              r0, #0
  175 000001E4 0A000002        BEQ              atoi_end    ; Branch to end of 
                                                            subroutine if NULL 
                                                            char
  176 000001E8 E2400030        SUB              r0, r0, #48 ; Conver to int
  177 000001EC E0220293        MLA              r2, r3, r2, r0
  178 000001F0 EAFFFFF9        B                atoi_loop
  179 000001F4         atoi_end
  180 000001F4 E3550001        CMP              r5, #1      ; Convert to two's 
                                                            comp if negative
  181 000001F8 01E02002        MVNEQ            r2, r2
  182 000001FC 02822001        ADDEQ            r2, r2, #1
  183 00000200 E1A00002        MOV              r0, r2      ; Return in r0
  184 00000204 E8BD401C        LDMFD            sp!, {lr, r2-r4}
  185 00000208 E12FFF1E        BX               lr
  186 0000020C         
  187 0000020C         itoa
  188 0000020C         ; Args r4 = base address to store result string
  189 0000020C         ;     r0 = int to convert
  190 0000020C         ; r2 = divisor 10
  191 0000020C         ; r3 = counter
  192 0000020C E92D401E        STMFD            SP!, {lr, r1-r4}
  193 00000210 E3A03000        MOV              r3, #0
  194 00000214 E3A0100A        MOV              r1, #10
  195 00000218         ; Check sign
  196 00000218 E3500000        CMP              r0, #0
  197 0000021C E3A0502D        MOV              r5, #0x2D   ; '-' char
  198 00000220 44C45001        STRBMI           r5, [r4], #1 ; if negative, ins
                                                            ert '-' char
  199 00000224 41E00000        MVNMI            r0, r0      ; if negative, conv
                                                            ert to two's comp
  200 00000228 42800001        ADDMI            r0, r0, #1
  201 0000022C         
  202 0000022C E3500000        CMP              r0, #0      ; if int == 0, stor
                                                            e in memory to writ
                                                            e and branch to end
                                                            
  203 00000230 1A000002        BNE              itoa_loop
  204 00000234 E2800030        ADD              r0, r0, #0x30 ; convert 0 to ch
                                                            ar '0'
  205 00000238 E4C40001        STRB             r0, [r4], #1 
                                                            ; store 0 in memory



ARM Macro Assembler    Page 6 


                                                            
  206 0000023C EA00000C        B                itoa_end    ; branch to end
  207 00000240         
  208 00000240         itoa_loop
  209 00000240 EB00000F        BL               div_and_mod
  210 00000244 E3510000        CMP              r1, #0      ; if remainder == 0
                                                            , branch to end
  211 00000248 0A000003        BEQ              itoa_pop
  212 0000024C E2811030        ADD              r1, r1, #48 ; Convert int to AS
                                                            CII
  213 00000250 E52D1004        PUSH             {r1}        ; Push onto stack
  214 00000254 E2833001        ADD              r3, r3, #1  ; Increment Counter
                                                            
  215 00000258 EAFFFFF8        B                itoa_loop
  216 0000025C         itoa_pop
  217 0000025C E3530000        CMP              r3, #0      ; Pop from stack un
                                                            til counter == 0
  218 00000260 0A000003        BEQ              itoa_end
  219 00000264 E49D1004        POP              {r1}
  220 00000268 E4C41001        STRB             r1, [r4], #1 ; Store popped cha
                                                            r into memory
  221 0000026C E2433001        SUB              r3, r3, #1
  222 00000270 EAFFFFF9        B                itoa_pop
  223 00000274         itoa_end
  224 00000274 E3A01000        MOV              r1, #0      ; append NULL char
  225 00000278 E5C41000        STRB             r1, [r4]
  226 0000027C E8BD401E        LDMFD            sp!, {lr, r1-r4}
  227 00000280 E12FFF1E        BX               lr
  228 00000284         
  229 00000284         div_and_mod
  230 00000284 E92D5FFC        STMFD            r13!, {r2-r12, r14}
  231 00000288         
  232 00000288         ; Your code for the signed division/mod routine goes her
                       e.  
  233 00000288         ; The dividend is passed in r0 and the divisor in r1.
  234 00000288         ; The quotient is returned in r0 and the remainder in r1
                       . 
  235 00000288         
  236 00000288         ; r0 = dividend
  237 00000288         ; r1 = divisor
  238 00000288         ; r2 = counter
  239 00000288         ; r3 = quotient
  240 00000288         ; r4 = remainder
  241 00000288         ; r5 = dividend sign
  242 00000288         ; r6 = divisor sign
  243 00000288         ; r7 = r5 XOR r6
  244 00000288         ; RETURN r0 = quotient
  245 00000288         ;    r1 = remainder
  246 00000288         
  247 00000288         ; check sign of dividend
  248 00000288 E3500000        CMP              r0, #0
  249 0000028C E3A05000        MOV              r5, #0
  250 00000290 43A05001        MOVMI            r5, #1
  251 00000294         ; if dividend < 0, convert to two's comp
  252 00000294 41E00000        MVNMI            r0, r0
  253 00000298 42800001        ADDMI            r0, r0, #1
  254 0000029C         
  255 0000029C         ; check sign of divisor
  256 0000029C E3510000        CMP              r1, #0



ARM Macro Assembler    Page 7 


  257 000002A0 E3A06000        MOV              r6, #0
  258 000002A4 43A06001        MOVMI            r6, #1
  259 000002A8         ; if divisor < 0, convert to two's comp
  260 000002A8 41E01001        MVNMI            r1, r1
  261 000002AC 42811001        ADDMI            r1, r1, #1
  262 000002B0         
  263 000002B0 E3A0200F        MOV              r2, #15     ; Init counter to 1
                                                            5
  264 000002B4 E3A03000        MOV              r3, #0      ; Init quotient to 
                                                            0
  265 000002B8 E1A01781        LSL              r1, r1, #15 ; lsl divisor by 15
                                                            
  266 000002BC E2804000        ADD              r4, r0, #0  ; Set remainder to 
                                                            dividend
  267 000002C0         loop
  268 000002C0 E0544001        SUBS             r4, r4, r1  ; rem = rem - divis
                                                            
  269 000002C4         
  270 000002C4         ; if(remainder < 0)
  271 000002C4 B0844001        ADDLT            r4, r4, r1  ; rem = rem + divis
                                                            
  272 000002C8 B1A03083        LSLLT            r3, #1      ; lsl quotient
  273 000002CC         ; else
  274 000002CC A1A03083        LSLGE            r3, #1      ; lsl quotient
  275 000002D0 A3833001        ORRGE            r3, r3, #1  ; set LSB of quot =
                                                             1
  276 000002D4         
  277 000002D4 E1A010A1        LSR              r1, r1, #1  ; right shift divis
                                                            
  278 000002D8 E2522001        SUBS             r2, r2, #1  ; decrement counter
                                                            
  279 000002DC 5AFFFFF7        BPL              loop        ; branch if count >
                                                            = 0
  280 000002E0         
  281 000002E0 E2830000        ADD              r0, r3, #0  ; set quot to r0
  282 000002E4 E2841000        ADD              r1, r4, #0  ; set remain to r1
  283 000002E8         
  284 000002E8 E0257006        EOR              r7, r5, r6
  285 000002EC E3570001        CMP              r7, #1
  286 000002F0         ; if dvnd != dvsr, convert answer to two's comp
  287 000002F0 01E00000        MVNEQ            r0, r0
  288 000002F4 02800001        ADDEQ            r0, r0, #1
  289 000002F8         
  290 000002F8 E8BD5FFC        LDMFD            r13!, {r2-r12, r14}
  291 000002FC E12FFF1E        BX               lr          ; Return to the C p
                                                            rogram 
  292 00000300         
  293 00000300         
  294 00000300         pin_connect_block_setup_for_uart0
  295 00000300 E92D4003        STMFD            sp!, {r0, r1, lr}
  296 00000304 E59F0034        LDR              r0, =0xE002C000 ; PINSEL0
  297 00000308 E5901000        LDR              r1, [r0]
  298 0000030C E3811005        ORR              r1, r1, #5
  299 00000310 E3C1100A        BIC              r1, r1, #0xA
  300 00000314 E5801000        STR              r1, [r0]
  301 00000318 E8BD4003        LDMFD            sp!, {r0, r1, lr}
  302 0000031C E12FFF1E        BX               lr
  303 00000320         
  304 00000320         



ARM Macro Assembler    Page 8 


  305 00000320         
  306 00000320                 END
              E000C00C 
              E000C000 
              E000C004 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              E002C000 
Command Line: --debug --xref --diag_suppress=9931 --apcs=interwork --depend=.\o
bjects\lab3part2skeleton.d -o.\objects\lab3part2skeleton.o -IC:\Keil_v5\ARM\RV3
1\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips --predefine="
__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 522" --list=.\listings\lab3p
art2skeleton.lst lab3part2skeleton.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

atoi 000001C0

Symbol: atoi
   Definitions
      At line 157 in file lab3part2skeleton.s
   Uses
      At line 70 in file lab3part2skeleton.s
      At line 73 in file lab3part2skeleton.s

atoi_end 000001F4

Symbol: atoi_end
   Definitions
      At line 179 in file lab3part2skeleton.s
   Uses
      At line 175 in file lab3part2skeleton.s
Comment: atoi_end used once
atoi_loop 000001DC

Symbol: atoi_loop
   Definitions
      At line 172 in file lab3part2skeleton.s
   Uses
      At line 178 in file lab3part2skeleton.s
Comment: atoi_loop used once
div_and_mod 00000284

Symbol: div_and_mod
   Definitions
      At line 229 in file lab3part2skeleton.s
   Uses
      At line 78 in file lab3part2skeleton.s
      At line 209 in file lab3part2skeleton.s

itoa 0000020C

Symbol: itoa
   Definitions
      At line 187 in file lab3part2skeleton.s
   Uses
      At line 84 in file lab3part2skeleton.s
      At line 95 in file lab3part2skeleton.s

itoa_end 00000274

Symbol: itoa_end
   Definitions
      At line 223 in file lab3part2skeleton.s
   Uses
      At line 206 in file lab3part2skeleton.s
      At line 218 in file lab3part2skeleton.s

itoa_loop 00000240

Symbol: itoa_loop
   Definitions
      At line 208 in file lab3part2skeleton.s
   Uses
      At line 203 in file lab3part2skeleton.s



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

      At line 215 in file lab3part2skeleton.s

itoa_pop 0000025C

Symbol: itoa_pop
   Definitions
      At line 216 in file lab3part2skeleton.s
   Uses
      At line 211 in file lab3part2skeleton.s
      At line 222 in file lab3part2skeleton.s

lab3 0000008C

Symbol: lab3
   Definitions
      At line 45 in file lab3part2skeleton.s
   Uses
      At line 2 in file lab3part2skeleton.s
Comment: lab3 used once
lib 00000000

Symbol: lib
   Definitions
      At line 1 in file lab3part2skeleton.s
   Uses
      None
Comment: lib unused
loop 000002C0

Symbol: loop
   Definitions
      At line 267 in file lab3part2skeleton.s
   Uses
      At line 279 in file lab3part2skeleton.s
Comment: loop used once
os_loop 00000158

Symbol: os_loop
   Definitions
      At line 120 in file lab3part2skeleton.s
   Uses
      At line 125 in file lab3part2skeleton.s
Comment: os_loop used once
output_character 00000198

Symbol: output_character
   Definitions
      At line 143 in file lab3part2skeleton.s
   Uses
      At line 56 in file lab3part2skeleton.s
      At line 66 in file lab3part2skeleton.s
      At line 88 in file lab3part2skeleton.s
      At line 106 in file lab3part2skeleton.s
      At line 113 in file lab3part2skeleton.s
      At line 123 in file lab3part2skeleton.s

output_string 00000154

Symbol: output_string



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 118 in file lab3part2skeleton.s
   Uses
      At line 50 in file lab3part2skeleton.s
      At line 53 in file lab3part2skeleton.s
      At line 60 in file lab3part2skeleton.s
      At line 63 in file lab3part2skeleton.s
      At line 82 in file lab3part2skeleton.s
      At line 85 in file lab3part2skeleton.s
      At line 92 in file lab3part2skeleton.s
      At line 96 in file lab3part2skeleton.s

pin_connect_block_setup_for_uart0 00000300

Symbol: pin_connect_block_setup_for_uart0
   Definitions
      At line 294 in file lab3part2skeleton.s
   Uses
      At line 3 in file lab3part2skeleton.s
Comment: pin_connect_block_setup_for_uart0 used once
prompt 00000000

Symbol: prompt
   Definitions
      At line 14 in file lab3part2skeleton.s
   Uses
      At line 83 in file lab3part2skeleton.s
      At line 93 in file lab3part2skeleton.s

prompt_dividend 00000024

Symbol: prompt_dividend
   Definitions
      At line 17 in file lab3part2skeleton.s
   Uses
      At line 49 in file lab3part2skeleton.s
      At line 51 in file lab3part2skeleton.s
      At line 69 in file lab3part2skeleton.s

prompt_divisor 00000012

Symbol: prompt_divisor
   Definitions
      At line 16 in file lab3part2skeleton.s
   Uses
      At line 59 in file lab3part2skeleton.s
      At line 61 in file lab3part2skeleton.s
      At line 72 in file lab3part2skeleton.s

read_character 00000174

Symbol: read_character
   Definitions
      At line 131 in file lab3part2skeleton.s
   Uses
      At line 104 in file lab3part2skeleton.s
Comment: read_character used once
read_string 00000124




ARM Macro Assembler    Page 4 Alphabetic symbol ordering
Relocatable symbols

Symbol: read_string
   Definitions
      At line 101 in file lab3part2skeleton.s
   Uses
      At line 52 in file lab3part2skeleton.s
      At line 62 in file lab3part2skeleton.s

response_quotient 00000037

Symbol: response_quotient
   Definitions
      At line 18 in file lab3part2skeleton.s
   Uses
      At line 81 in file lab3part2skeleton.s
Comment: response_quotient used once
response_remainder 00000043

Symbol: response_remainder
   Definitions
      At line 19 in file lab3part2skeleton.s
   Uses
      At line 91 in file lab3part2skeleton.s
Comment: response_remainder used once
rs_loop 00000128

Symbol: rs_loop
   Definitions
      At line 103 in file lab3part2skeleton.s
   Uses
      At line 108 in file lab3part2skeleton.s
Comment: rs_loop used once
rstart 0000017C

Symbol: rstart
   Definitions
      At line 134 in file lab3part2skeleton.s
   Uses
      At line 137 in file lab3part2skeleton.s
Comment: rstart used once
tstart 000001A4

Symbol: tstart
   Definitions
      At line 148 in file lab3part2skeleton.s
   Uses
      At line 151 in file lab3part2skeleton.s
Comment: tstart used once
uart_init 00000050

Symbol: uart_init
   Definitions
      At line 22 in file lab3part2skeleton.s
   Uses
      At line 4 in file lab3part2skeleton.s
Comment: uart_init used once
26 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

U0BA E000C000

Symbol: U0BA
   Definitions
      At line 9 in file lab3part2skeleton.s
   Uses
      At line 122 in file lab3part2skeleton.s
Comment: U0BA used once
U0LCR 0000000C

Symbol: U0LCR
   Definitions
      At line 8 in file lab3part2skeleton.s
   Uses
      None
Comment: U0LCR unused
U0LSR 00000014

Symbol: U0LSR
   Definitions
      At line 7 in file lab3part2skeleton.s
   Uses
      At line 135 in file lab3part2skeleton.s
      At line 149 in file lab3part2skeleton.s

3 symbols
363 symbols in table
